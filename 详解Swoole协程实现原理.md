#### 详解Swoole协程的实现

###### 写在最前

Swoole 协程的诞生经历了几个大的阶段，我们要在前进的道路上时常总结和回顾自己的发展历程。

###### 什么是协程？

协程的概念早就出现了，摘自 `wiki`：

> According to Donald Knuth, the term coroutine was coined by Melvin Conway in 1958, after he applied it to construction of an assembly program.  The first published explanation of the coroutine appeared later, in 1963.

协程要比 C 语言历史更长，究其概念，协程是一种子程序，可以通过 `yield` 的方式转移程序控制权，协程之间不是调用者与被调用者的关系，而是彼此对称，平等的。协程完全由用户态程序控制，所以也被称为用户态的线程。协程由用户以非抢占式的方式调度，而不是操作系统。正因为如此，没有系统调度和上下文切换的开销，协程实现了**轻量，高效，快速**等特点。（大部分为非抢占式，但是比如 `go` 在 1.4 版本也加入了抢占式调度，其中一个协程发生死循环，不至于其他协程被“饿死”。需要在必要的时刻让出CPU，Swoole 后续也会增加这个特性）。

协程开始流行很大一部分原因归功于 `go` 语言的流行，很多人开始使用它。目前支持协程的语言由很多，`go`，`lua`，`python`，`C#`，`Javascript`。我们可以用很短的时间用 C/C++ 描述出协程的模型，当然 php 也有自己的协程实现，也就是生成器，在此不探讨这个点。

###### Swoole 1.x 版本

Swoole 最终设计目的是要做**高性能网络通讯引擎**， Swoole 1.x 的编码主要是异步回调的方式，虽然性能很高效，但很多开发者会发现，随着项目工程的复杂度上升，用异步回调方式写业务逻辑是和我们人的正常思维方式不那么符合的。尤其是回调中嵌套了多层子回调时，不仅维护成本指数级上升，而且犯错的几率也在加速上升。

更符合人类思维习惯的方式是：同步的代码，运行出异步非阻塞的效果。所以 Swoole 很早就开始研究如何达到这个目的。

