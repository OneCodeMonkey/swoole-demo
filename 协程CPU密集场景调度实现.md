#### 协程CPU密集场景调度实现

###### 抢占式 / 非抢占式

如果服务场景是 IO 密集型，那么非抢占式可行。如果服务中加入了CPU密集型操作，我们就不得不考虑重新安排协程的调度模式了。

在 Swoole 协程系列文章中我们曾经介绍过 IO 密集场景下协程基于非抢占式调度的优势和卓越的性能。但是在CPU密集的场景下抢占式调度是非常重要的。试想有以下场景，程序中有 A,B 两个协程，协程A一直在执行 CPU 密集型的计算，非抢占式的调度模型中，A不会主动让出控制权，从而导致B得不到时间片，协程得不到均衡调度。导致的问题是假如当前服务 A，B同时对外提供服务，B协程处理的请求就可能因为得不到时间片而导致请求超时，在企业级应用中，这种情况是有危害的。

###### php 对此的应对方式

由于php是单线程运行的，所以针对 php 的协程调度和 `go` 完全不同，我们选择使用 `declare(tick=N)` 语法功能实现协程调度。Tick（时钟周期）是一个在 declare 代码段中解释器每执行 N 条可计时的低级语句就会发生的事情。N 的值是在 declare 中的 directive 部分用 ticks = N 来指定的。

